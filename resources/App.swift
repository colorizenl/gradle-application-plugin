//-----------------------------------------------------------------------------
// File generated by Colorize Gradle application plugin
//-----------------------------------------------------------------------------

import SwiftUI
import WebKit

@main
struct HybridWebApp: App {
    var body: some Scene {
        WindowGroup {
            HybridWebView()
                .ignoresSafeArea()
        }
    }
}

struct HybridWebView: UIViewRepresentable {
    typealias UIViewType = WKWebView

    func makeUIView(context: Context) -> WKWebView {
        let preferences: WKPreferences = WKPreferences()
        preferences.javaScriptEnabled = true
        preferences.setValue(true, forKey: "developerExtrasEnabled")
        
        let scriptController: WKUserContentController = WKUserContentController()
        scriptController.addUserScript(WKUserScript(source: generateBridge(),
            injectionTime: .atDocumentEnd, forMainFrameOnly: false))

        let config: WKWebViewConfiguration = WKWebViewConfiguration()
        config.preferences = preferences
        config.userContentController = scriptController
        config.setValue(true, forKey: "allowUniversalAccessFromFileURLs")

        let webView = WKWebView(frame: .zero, configuration: config)
        webView.scrollView.contentInsetAdjustmentBehavior = .never
        if #available(iOS 16.4, *) {
            webView.isInspectable = true
        }
        
        let scriptBridge = ScriptBridge(webView: webView)
        scriptController.add(scriptBridge, name: "openNativeBrowser")
        scriptController.add(scriptBridge, name: "loadPreferences")
        scriptController.add(scriptBridge, name: "savePreferences")
        scriptController.add(scriptBridge, name: "requestNotifications")
        scriptController.add(scriptBridge, name: "scheduleNotification")
        scriptController.add(scriptBridge, name: "cancelNotification")
        webView.navigationDelegate = scriptBridge
        
        return webView
    }
    
    func updateUIView(_ webView: WKWebView, context: Context) {
        DispatchQueue.main.async {
            let index = "HybridResources/index"
            let path = Bundle.main.path(forResource: index, ofType: "html")!
            let url = URL(fileURLWithPath: path)
            webView.loadFileURL(url, allowingReadAccessTo: url)
        }
    }
    
    func generateBridge() -> String {
        return """
            window.clrz = {
                openNativeBrowser: function(url) {
                    window.webkit.messageHandlers.openNativeBrowser.postMessage({url});
                },
                loadPreferences: function() {
                    window.webkit.messageHandlers.loadPreferences.postMessage({});
                },
                savePreferences: function(name, value) {
                    window.webkit.messageHandlers.savePreferences.postMessage({name, value});
                },
                requestNotifications: function() {
                    window.webkit.messageHandlers.requestNotifications.postMessage({});
                },
                scheduleNotification: function(id, title, preview, schedule) {
                    const message = {id, title, preview, schedule};
                    window.webkit.messageHandlers.scheduleNotification.postMessage(message);
                },
                cancelNotification: function(id) {
                    window.webkit.messageHandlers.cancelNotification.postMessage({id});
                }
            };
        """
    }
}

class ScriptBridge: NSObject, WKScriptMessageHandler, WKNavigationDelegate, UNUserNotificationCenterDelegate {
    var webView: WKWebView
    
    init(webView: WKWebView) {
        self.webView = webView
    }

    func webView(_ webView: WKWebView,
                 decidePolicyFor navigationAction: WKNavigationAction,
                 decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        if let url = navigationAction.request.url {
            if url.absoluteString.starts(with: "https://") {
                UIApplication.shared.open(url)
                decisionHandler(.cancel)
                return
            }
        }

        decisionHandler(.allow)
    }

    func userNotificationCenter(_ center: UNUserNotificationCenter,
                                willPresent notification: UNNotification,
                                withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler(.banner)
    }
    
    func userContentController(_ userContentController: WKUserContentController,
                               didReceive message: WKScriptMessage) {
        let body: NSDictionary = message.body as! NSDictionary

        if message.name == "openNativeBrowser" {
            let url: String = body["url"] as! String;
            UIApplication.shared.open(URL(string: url)!)
        } else if message.name == "loadPreferences" {
            loadPreferences(body)
        } else if message.name == "savePreferences" {
            savePreferences(body)
        } else if message.name == "requestNotifications" {
            requestNotifications()
        } else if message.name == "scheduleNotification" {
            scheduleNotification(body)
        } else if message.name == "cancelNotification" {
            cancelNotification(body)
        }
    }

    func loadPreferences(_ body: NSDictionary) {
        for key in UserDefaults.standard.dictionaryRepresentation().keys {
            let value = UserDefaults.standard.string(forKey: key)
            if value != nil {
                webView.evaluateJavaScript("window.localStorage.setItem('\(key)', '\(value!)');");
            }
        }
    }
    
    func savePreferences(_ body: NSDictionary) {
        let name: String = body["name"] as! String
        let value: String = body["value"] as! String
        UserDefaults.standard.set(value, forKey: name)
    }

    func requestNotifications() {
        let notificationCenter = UNUserNotificationCenter.current()
        notificationCenter.delegate = self
        notificationCenter.requestAuthorization(options: [.alert, .badge]) { (granted, error) in
            if error != nil {
                print("Failed to request notification permission: \(error)")
            }
        }
    }

    func scheduleNotification(_ body: NSDictionary) {
        let id: String = body["id"] as! String
        let title: String = body["title"] as! String
        let preview: String = body["preview"] as! String
        let date: String = body["schedule"] as! String

        let content = UNMutableNotificationContent()
        content.title = title
        content.body = preview

        let schedule = parseNotificationSchedule(date)
        let trigger = UNCalendarNotificationTrigger(dateMatching: schedule, repeats: false)
        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)
        let notificationCenter = UNUserNotificationCenter.current()
        notificationCenter.add(request) { (error) in
            if error != nil {
                print("Failed to schedule notification: \(error)")
            }
       }
    }

    func parseNotificationSchedule(_ schedule: String) -> DateComponents {
        let dateFormat = DateFormatter()
        dateFormat.locale = Locale.current
        dateFormat.timeZone = Calendar.current.timeZone
        dateFormat.dateFormat = "yyyy-MM-dd HH:mm:ss"

        let date = dateFormat.date(from: schedule)!
        return Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second],
            from: date)
    }

    func cancelNotification(_ body: NSDictionary) {
        let id: String = body["id"] as! String
        let notificationCenter = UNUserNotificationCenter.current()
        notificationCenter.removePendingNotificationRequests(withIdentifiers: [id])
    }
}
