//-----------------------------------------------------------------------------
// File generated by Colorize Gradle application plugin
//-----------------------------------------------------------------------------

import SwiftUI
import WebKit

class ScriptBridge: NSObject, WKScriptMessageHandler, WKNavigationDelegate, UNUserNotificationCenterDelegate {
    var webView: WKWebView
    
    init(webView: WKWebView) {
        self.webView = webView
    }

    func webView(_ webView: WKWebView,
                 decidePolicyFor navigationAction: WKNavigationAction,
                 decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        if let url = navigationAction.request.url {
            if url.absoluteString.starts(with: "https://") {
                UIApplication.shared.open(url)
                decisionHandler(.cancel)
                return
            }
        }

        decisionHandler(.allow)
    }

    func userNotificationCenter(_ center: UNUserNotificationCenter,
                                willPresent notification: UNNotification,
                                withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler(.banner)
    }
    
    func userContentController(_ userContentController: WKUserContentController,
                               didReceive message: WKScriptMessage) {
        let body: NSDictionary = message.body as! NSDictionary

        if message.name == "openNativeBrowser" {
            let url: String = body["url"] as! String;
            UIApplication.shared.open(URL(string: url)!)
        } else if message.name == "loadPreferences" {
            loadPreferences(body)
        } else if message.name == "savePreferences" {
            savePreferences(body)
        } else if message.name == "requestNotifications" {
            requestNotifications()
        } else if message.name == "scheduleNotification" {
            scheduleNotification(body)
        } else if message.name == "cancelNotification" {
            cancelNotification(body)
        }
    }

    func loadPreferences(_ body: NSDictionary) {
        for key in UserDefaults.standard.dictionaryRepresentation().keys {
            let value = UserDefaults.standard.string(forKey: key)
            if value != nil {
                webView.evaluateJavaScript("window.localStorage.setItem('\(key)', '\(value!)');");
            }
        }
    }
    
    func savePreferences(_ body: NSDictionary) {
        let name: String = body["name"] as! String
        let value: String = body["value"] as! String
        UserDefaults.standard.set(value, forKey: name)
    }

    func requestNotifications() {
        let notificationCenter = UNUserNotificationCenter.current()
        notificationCenter.delegate = self
        notificationCenter.requestAuthorization(options: [.alert, .badge]) { (granted, error) in
            if error != nil {
                print("Failed to request notification permission: \(error)")
            }
        }
    }

    func scheduleNotification(_ body: NSDictionary) {
        let id: String = body["id"] as! String
        let title: String = body["title"] as! String
        let preview: String = body["preview"] as! String
        let date: String = body["schedule"] as! String

        let content = UNMutableNotificationContent()
        content.title = title
        content.body = preview

        let schedule = parseNotificationSchedule(date)
        let trigger = UNCalendarNotificationTrigger(dateMatching: schedule, repeats: false)
        let request = UNNotificationRequest(identifier: id, content: content, trigger: trigger)
        let notificationCenter = UNUserNotificationCenter.current()
        notificationCenter.add(request) { (error) in
            if error != nil {
                print("Failed to schedule notification: \(error)")
            }
       }
    }

    func parseNotificationSchedule(_ schedule: String) -> DateComponents {
        let dateFormat = DateFormatter()
        dateFormat.locale = Locale.current
        dateFormat.timeZone = Calendar.current.timeZone
        dateFormat.dateFormat = "yyyy-MM-dd HH:mm:ss"

        let date = dateFormat.date(from: schedule)!
        return Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second],
            from: date)
    }

    func cancelNotification(_ body: NSDictionary) {
        let id: String = body["id"] as! String
        let notificationCenter = UNUserNotificationCenter.current()
        notificationCenter.removePendingNotificationRequests(withIdentifiers: [id])
    }
}
